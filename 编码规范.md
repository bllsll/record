以下是一份针对 C++ 后端开发的编程规范，涵盖代码风格、命名规范、内存管理、性能优化等核心方面，适用于中大型后端项目开发，旨在提升代码可读性、可维护性和安全性。

### 一、代码风格

1. **空格与括号**
   - 关键字（`if`、`for`、`while` 等）与括号之间加空格，函数名与括号之间不加空格。
     示例：`if (a > b)`、`func(a, b)`。
   - 二元运算符（`+`、`=`、`&&` 等）前后加空格，一元运算符（`!`、`++` 等）前后不加空格。
     示例：`a = b + c`、`if (!valid)`、`++i`。
   - 逗号、分号后加空格（除非位于行尾）。示例：`func(a, b, c)`。
   - 括号内侧不加空格。示例：`int arr[10]`（非 `int arr[ 10 ]`）。
   - 代码中缩进尽量不用tab，用4个空格代替。
   - 所有变量必须初始化（尤其是指针，默认初始化为nullptr

### 二、命名规范

1. **通用原则**

   - 命名需清晰表达含义，避免缩写（公认缩写如 `msg`、`ptr` 除外）。
   - 禁止使用单字母命名（循环变量 `i`、`j` 等除外）。

2. **具体命名规则**

   | 元素        | 命名风格                   | 示例                                       |
   | ----------- | -------------------------- | ------------------------------------------ |
   | 变量 / 函数 | 小驼峰式（lowerCamelCase） | `userName`、`sendMessage()`                |
   | 类 / 结构体 | 大驼峰式（UpperCamelCase） | `UserManager`、`HttpRequest`               |
   | 常量        | 全大写 + 下划线            | `MAX_BUFFER_SIZE`、`TIMEOUT_MS`            |
   | 枚举值      | 全大写 + 下划线            | `STATUS_SUCCESS`、`LOG_LEVEL_ERROR`        |
   | 宏定义      | 全大写 + 下划线            | `#define CHECK_NULL(ptr) if (!ptr) return` |
   | 文件名      | 小写 + 下划线              | `user_service.cpp`、`http_utils.h`         |

### 二、作用域前缀（区分变量所属范围）

| 作用域     | 前缀 | 示例                            | 说明                                          |
| ---------- | ---- | ------------------------------- | --------------------------------------------- |
| 类成员变量 | `m_` | `m_user_name`、`m_max_count`    | 所有非静态成员变量均需加 `m_`，区分局部变量。 |
| 类静态成员 | `s_` | `s_global_config`、`s_instance` | 类的静态变量，属于类级别而非实例。            |
| 全局变量   | `g_` | `g_logger`、`g_event_loop`      | 尽量避免使用，必须使用时加 `g_` 前缀。        |
| 局部变量   | 无   | `temp_buffer`、`loop_index`     | 函数内部变量，无需作用域前缀。                |
| 函数参数   | 无   | `user_id`、`timeout_ms`         | 函数参数直接用含义命名，不加作用域前缀。      |

### 三、头文件与依赖管理

1. **头文件保护**

   - 所有头文件必须使用

     ```
     #ifndef/#define/#endif（宏守卫，标准机制）
     ```

     举例：

     ```cpp
     用法
     cpp
     #ifndef __H_GAME_H__  // 宏名通常为头文件名的大写+下划线，确保唯一
     #define __H_GAME_H__
     
     #include <string>
     
     class Game {
         // ...
     };
     #endif
     ```

### 四、类型与变量

1. **类型选择**

   - 优先使用 C++ 标准类型（`std::string`、`std::vector`），避免 C 风格类型（`char*`、`int[]`）。
   - 明确数值范围时，使用精确宽度类型（如 `int32_t`、`uint64_t`），而非 `int`、`long`（平台相关）。
   - 布尔变量命名需包含判断语义，如 `isValid`、`hasError`，禁止使用 `flag` 等模糊名称。

2. **变量初始化**

   - 所有变量必须初始化（尤其是指针，默认初始化为

     ```
     nullptr
     ```

     示例：

     ```cpp
     int count = 0;
     std::string name = "";
     User* user = nullptr;  // 禁止使用 NULL 或 0
     ```

   - 成员变量在构造函数初始化列表中初始化，而非函数体内。

     示例：

     ```cpp
     // 推荐
     UserManager::UserManager() : maxUsers(100), isRunning(false) {}
     
     // 不推荐
     UserManager::UserManager() {
         maxUsers = 100;
         isRunning = false;
     }
     ```

### 五、函数与接口

1. **函数设计**

   - 函数职责单一，长度不超过 50 行（超出需拆分）。

   - 函数参数不超过 5 个（过多时封装为结构体）。

   - 输出参数需明确标记（如指针且加OUT注释），优先返回值而非输出参数。

     示例：

     cpp

     ```cpp
     // 推荐（返回值）
     std::string formatMessage(const std::string& raw);
     
     // 不推荐（输出参数）
     void formatMessage(const std::string& raw, std::string* out);
     ```

2. **错误处理**

   - 后端函数优先使用返回值（如 `bool`、错误码 `int`）或 `std::optional` 表示成功 / 失败，避免滥用异常（异常用于罕见错误）。
   - 跨模块接口需定义明确的错误码枚举（如 `enum class ErrorCode { SUCCESS, INVALID_PARAM, NETWORK_ERROR }`）。

### 六、内存管理

1. **禁止裸指针**
   - 优先使用智能指针管理动态内存：
     - `std::unique_ptr`：独占所有权（如局部对象、成员变量）。
     - `std::shared_ptr`：共享所有权（如跨模块对象）。
   - 禁止手动调用 `new`/`delete`，禁止使用 `void*` 进行内存操作。
2. **容器使用**
   - 遍历容器时，优先使用范围 for 循环（`for (const auto& item : container)`）。
   - 容器清空优先使用 `clear()`，而非重新构造（如 `vec.clear()` 优于 `vec = {}`）。
   - 避免在循环中频繁调用 `push_back()` 导致容器扩容，提前用 `reserve()` 预分配空间。

### 七、面向对象与设计

1. **类设计**

   - 成员变量默认设为 `private`，通过 `public` 方法访问（封装原则）。
   - 禁止使用 `friend`（破坏封装，特殊场景需团队评审）。
   - 继承时明确使用 `public` 继承（禁止 `private`/`protected` 继承，避免语义模糊），且符合 “is-a” 关系。

2. **接口抽象**

   - 跨模块交互通过纯虚基类（接口）实现，禁止直接依赖具体类。

     示例：

     cpp

     

     

     

     

     

     ```cpp
     class DatabaseInterface {
     public:
         virtual ~DatabaseInterface() = default;
         virtual bool query(const std::string& sql) = 0;
     };
     
     class MysqlDatabase : public DatabaseInterface {
         bool query(const std::string& sql) override { /* 实现 */ }
     };
     ```

### 八、性能与安全

1. **性能优化**
   - 避免不必要的拷贝：函数参数为大对象时，优先传 `const&`（如 `const std::string&`）。
   - 循环中避免重复计算（如将 `container.size()` 提取到循环外）。
   - 高频调用的函数加 `inline`（但避免对长函数使用）。
2. **安全规范**
   - 禁止使用 `gets()`、`sprintf()` 等不安全函数，改用 `fgets()`、`snprintf()` 或 C++ 流。
   - 字符串操作需检查边界（避免缓冲区溢出），优先使用 `std::string` 的 `substr`、`find` 等方法。
   - 多线程环境中，共享变量必须加锁（`std::mutex`），或使用原子类型（`std::atomic`）。

### 九、注释规范

1. **文件注释**

   - 每个

      

     ```
     .h
     ```

     /

     ```
     .cpp
     ```

      

     文件开头添加注释，说明功能、作者、创建日期。

     示例：

     cpp

     

     

     

     

     

     ```cpp
     /**
      * @file user_service.h
      * @brief 用户服务模块，处理用户注册、登录逻辑
      * @author Zhang San
      * @date 2024-08-01
      */
     ```

2. **函数注释**

   - 函数前需注释功能、参数含义、返回值、异常（如有）。

     示例：

     cpp

     

     

     

     

     

     ```cpp
     /**
      * @brief 验证用户密码
      * @param userName 用户名（非空）
      * @param password 密码（明文，长度 6-20）
      * @return true 验证成功，false 验证失败
      */
     bool verifyPassword(const std::string& userName, const std::string& password);
     ```

3. **代码注释**

   - 复杂逻辑（如算法、特殊处理）需加行内注释，说明 “为什么这么做”（而非 “做了什么”）。

     示例：

     cpp

     

     

     

     

     

     ```cpp
     // 延迟 100ms 避免高频重试导致的服务器压力（非 obvious 逻辑）
     std::this_thread::sleep_for(100ms);
     ```

### 十、工具与自动化

1. **格式化工具**
   - 使用 `clang-format` 统一代码风格，项目根目录添加 `.clang-format` 配置文件。
2. **静态检查**
   - 集成 `cppcheck`、`clang-tidy` 等工具，禁止通过有警告的代码（编译选项加 `-Werror`）。
3. **版本控制**
   - 提交代码前自检，单次提交不超过 300 行（便于评审）。
   - 提交信息格式：`[模块] 操作：具体描述`（如 `[user] fix: 修复密码验证逻辑漏洞`）。

### 总结

本规范旨在平衡可读性、安全性和性能，团队可根据项目特点微调（如异常使用策略、命名细节），但核心原则（如禁止裸指针、封装、注释规范）需严格遵守。规范的落地依赖工具链自动化检查和代码评审，而非单纯人工遵守。