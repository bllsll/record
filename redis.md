# Redis基础知识

>  Redis:remote dictionary service的简称，远程字典服
>
> 所有数据库都是请求回应模式，通过tcp和redis建立连接交互
>
> 通过字典的方式索引搜索，kv数据库，所有的key都是string
>
> 内存数据库：所有数据都在内存中。不会存在一部分数据在内存，一部分数据在磁盘中。

### redis常用数据结构

- string ： 字符串，和c++中的string一样，都是二进制安全的

> 1. **二进制安全**
>    - 可以存储任意二进制数据（如图片、序列化对象等）
>    - 长度不依赖于特定字符（如 C 语言中的 `\0` 终止符）
>    - 最大长度为 512MB

- List : 列表

- hash

- set：集合，里面元素不会相同

- zset：有序集合, 里面的member不会相同，根据score排序

  > 第一次用什么命令决定了这个key是什么数据结构，比如set key ’asdfad‘ ，那么key的结构为string

![image-20250621145840861](/Users/shilinling/Library/Application Support/typora-user-images/image-20250621145840861.png)

### redis中命令

## 对key的命令

- ##### `DEL key [key ...]`

  - **功能**：删除一个或多个键
  - **原理**：从数据库字典中删除键值对，释放内存
  - **时间复杂度**：O (N)，N 为删除的键数量
  - **内存回收**：Redis 使用惰性删除和定期删除策略，DEL 是立即删除，会释放内存

- ##### `EXPIRE key seconds`

  - **功能**：设置键的过期时间
  - **原理**：将键的过期时间存入过期字典，到期后通过惰性或定期删除处理
  - **时间复杂度**：O(1)
  - **过期策略**：惰性删除（访问时检查）+ 定期删除（随机抽查），避免全量扫描

- ##### `KEYS pattern`

  - **功能**：查找匹配模式的键
  - **原理**：遍历数据库字典的所有键，用模式匹配算法过滤
  - **时间复杂度**：O (N)，N 为数据库键数量
  - **性能风险**：在生产环境禁止使用 KEYS，会阻塞主线程，建议用 `SCAN` 替代

- ##### `PERSIST key`

  - **功能**：移除键的过期时间
  - **原理**：从过期字典中删除该键的记录
  - **时间复杂度**：O(1)
  - **应用场景**：适用于临时数据转永久存储的场景

- 

dump key 序列化key，并返回系列化的值

exists key 检查key是否存在

expire key seconds 设置过期时间，以s计

expireat key timestamp 

## string

- `GET key`

  - **功能**：获取字符串类型键的值
  - **原理**：通过哈希表（字典）直接查询键值对，Redis 字典采用链地址法解决哈希冲突
  - **时间复杂度**：O(1)
  - **实现细节**：字典的底层是哈希表，查找操作通过哈希函数计算槽位，平均情况下直接定位到目标节点

- ##### `SET key value [EX seconds] [PX milliseconds] [NX|XX]`

  - **功能**：设置字符串值，支持过期时间和条件赋值
  - 原理
    - 直接更新哈希表中的键值对
    - 过期时间通过过期字典（另一层哈希表）维护
    - `NX/XX` 通过原子操作实现条件判断
  - **时间复杂度**：O(1)
  - **实现细节**：SET 命令在 Redis 中是原子操作，通过 `setKey` 函数完成字典更新，过期时间存储在 `redisObject` 结构中

- ##### `INCR key`

  - **功能**：对数值型字符串自增 1
  - 原理
    - 检查值是否为整数，非整数报错
    - 直接在内存中进行数值运算，不涉及字符串解析
    - 结果重新写入哈希表
  - **时间复杂度**：O(1)
  - **实现细节**：Redis 用 `sds`（简单动态字符串）存储字符串，数值型会特殊标记，INCR 直接操作数值而非字符串转换

- ##### `MGET key1 [key2 ...]`

  - **功能**：批量获取多个键的值
  - **原理**：循环执行 GET 操作，通过哈希表逐个查询
  - **时间复杂度**：O (N)，N 为键的数量
  - **优化点**：相比多次单 GET，减少网络往返次数，提升批量操作效率

## list

- ##### `LPUSH key value [value ...]`

  - **功能**：在列表左侧插入元素
  - 原理
    - 列表底层由双向链表（quicklist）实现
    - 新元素创建节点后插入链表头部
  - **时间复杂度**：O(1)
  - **数据结构**：quicklist 是压缩列表（ziplist）的链表，当元素较少时使用压缩列表优化内存

- ##### `RPOP key`

  - **功能**：从列表右侧弹出元素
  - **原理**：通过双向链表尾指针直接访问最后一个节点，删除并返回值
  - **时间复杂度**：O(1)
  - **实现细节**：双向链表支持 O (1) 时间的头尾操作，中间操作需遍历

- ##### `LINDEX key index`

  - **功能**：获取列表指定索引的元素
  - **原理**：从链表头部或尾部开始遍历，直到找到目标索引
  - **时间复杂度**：O (N)，N 为列表长度
  - **性能提示**：大列表应避免频繁使用 LINDEX，可改用有序集合（ZSet）按索引存储

- ##### `LRANGE key start stop`

  - **功能**：获取列表指定范围的元素
  - **原理**：根据 start 和 stop 确定遍历方向（从头或从尾），分段读取元素
  - **时间复杂度**：O (S+N)，S 为起始偏移量，N 为返回元素数
  - **优化点**：Redis 会对范围进行边界检查，若 start 超过列表长度则返回空

## hash

- ##### `HSET key field value`

  - **功能**：在哈希表中设置字段值
  - 原理
    - 键对应的值是一个哈希表（字典），字段作为内层字典的键
    - 采用链地址法解决哈希冲突
  - **时间复杂度**：O(1)
  - **实现细节**：当哈希表节点数超过阈值时，会触发渐进式 rehash，避免阻塞主线程

- ##### `HGET key field`

  - **功能**：获取哈希表中字段的值
  - **原理**：通过外层字典找到哈希表，再在内层字典中查询字段
  - **时间复杂度**：O(1)
  - **内存优化**：当字段数较少且值为小整数时，会使用压缩列表（ziplist）存储，减少内存占用

- ##### `HGETALL key`

  - **功能**：获取哈希表所有字段和值
  - **原理**：遍历内层字典的所有节点，收集键值对
  - **时间复杂度**：O (N)，N 为字段数量
  - **性能风险**：若哈希表包含大量字段，会阻塞主线程，建议分批获取或使用 `HSCAN` 渐进式遍历

- ##### `HINCRBY key field increment`

  - **功能**：对哈希表中的数值字段自增指定值
  - **原理**：直接操作内层字典的数值型字段，无需字符串解析
  - **时间复杂度**：O(1)
  - **应用场景**：适用于计数器场景，如用户积分系统

## set

- ##### `SADD key member [member ...]`

  - **功能**：向集合中添加元素（去重）
  - 原理
    - 集合底层使用哈希表或有序整数数组（intset）
    - 当元素为整数且数量较少时使用 intset，否则用哈希表
  - **时间复杂度**：平均 O (1)，最坏 O (N)（哈希冲突时）
  - **内存优化**：intset 存储整数时比哈希表更节省内存，且查找效率更高

- ##### `SISMEMBER key member`

  - **功能**：判断元素是否在集合中
  - **原理**：根据底层数据结构选择哈希表查询或二分查找（intset）
  - **时间复杂度**：O (1)（哈希表）或 O (logN)（intset）
  - **实现细节**：intset 是有序的，通过二分查找提升查询效率

- ##### `SMEMBERS key`

  - **功能**：获取集合所有元素
  - **原理**：遍历底层数据结构（哈希表或 intset）的所有元素
  - **时间复杂度**：O (N)，N 为集合元素数量
  - **性能风险**：大集合使用 SMEMBERS 会阻塞主线程，建议用 `SSCAN` 渐进式遍历

- ##### `SINTER key1 [key2 ...]`

  - **功能**：计算多个集合的交集
  - 原理
    - 以最小集合为基准，遍历元素检查是否存在于其他集合
    - 底层通过哈希表的 `dictFind` 实现快速查找
  - **时间复杂度**：O (N*M)，N 为最小集合元素数，M 为集合数量
  - **优化策略**：Redis 会自动选择最小的集合作为基准，减少遍历次数

## zset

- ##### `ZADD key score member [score member ...]`

  - **功能**：向有序集合添加元素（按分数排序）
  - 原理
    - 底层使用跳表（skiplist）和哈希表双重结构
    - 跳表用于按分数排序，哈希表用于 O (1) 时间查询分数
  - **时间复杂度**：O (logN)，跳表插入操作的平均时间复杂度
  - **数据结构**：跳表的层级随机生成，保证查找、插入、删除均为 O (logN) 复杂度

- ##### `ZSCORE key member`

  - **功能**：获取元素的分数
  - **原理**：通过哈希表直接查询元素对应的分数
  - **时间复杂度**：O(1)
  - **实现细节**：哈希表的键是元素值，值是对应的分数，与跳表共享数据

- ##### `ZRANGE key start stop [WITHSCORES]`

  - **功能**：按排名获取有序集合元素（升序）
  - **原理**：从跳表头部开始遍历，按层级快速定位目标范围
  - **时间复杂度**：O (logN + M)，N 为集合大小，M 为返回元素数
  - **优化点**：跳表的多层索引结构允许快速跳过无关元素，提升范围查询效率

- ##### `ZREMRANGEBYRANK key start stop`

  - **功能**：按排名删除元素
  - **原理**：在跳表中找到起始和结束位置，删除对应节点
  - **时间复杂度**：O (logN + M)，M 为删除元素数
  - **底层操作**：跳表删除节点后会重新平衡层级，保证后续操作效率

#### **七、命令性能优化总结**

1. **避免大复杂度操作**：
   - 禁止使用 `KEYS`、`HGETALL`、`SMEMBERS` 等全量操作，改用 `SCAN` 系列渐进式命令
   - 大列表避免使用 `LINDEX`，改用 ZSet 按索引存储
2. **利用批量操作**：
   - 使用 `MGET`、`MSET`、`PIPELINE` 减少网络往返，提升批量操作效率
   - 事务（`MULTI`/`EXEC`）可保证多个命令的原子性执行
3. **数据结构选择**：
   - 小集合用 `intset`（内存更优），大集合用哈希表
   - 有序数据优先使用 ZSet（跳表），避免列表的 O (N) 范围查询
4. **过期策略优化**：
   - 合理设置过期时间，减少内存占用
   - 对时效性要求高的数据使用 `EXPIRE`，而非主动调用 `DEL`
