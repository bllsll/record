- 缓存击穿，大量请求下，redis中一个热点key失效，直接请求mysql。 方法：1.热点key设置不过期，2.互斥锁

- 缓存雪崩：大量请求下，redis大量key同时失效或者挂掉了。方法：1.key的过期时间不要都设置成一样的。2.互斥锁，3.用redis集群，避免只有一天redis机器挂掉。

- 缓存穿透：查询一个不存在redis和mysql数据库中的数据。导致每次请求都会去mysql中查询。方法：1.缓存这个不存在的数据，2.使用参数校验，可以过滤掉一些非法请求。3.redis前使用布隆过滤器

- redis和数据库读写一致

  - 由于数据更新，数据库和redis中都有一份数据，怎么达成一致

  - 方法：1.删除redis中的缓存，2.更新mysql中的数据，3.延迟1s左右。4.删除redis中的缓存。

- 超卖问题





#### **七、命令性能优化总结**

1. **避免大复杂度操作**：
   - 禁止使用 `KEYS`、`HGETALL`、`SMEMBERS` 等全量操作，改用 `SCAN` 系列渐进式命令
   
     - 除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫
   
       描遍历命令，解决诸如hgetall、smembers、zrange可能产生的阻塞问题，对
   
       应的命令分别是hscan、sscan、zscan
   
     渐进式遍历可以有效的解决keys命令可能产生的阻塞问题，但是scan并
   
     非完美无瑕，如果在scan的过程中如果有键的变化（增加、删除、修改），
   
     164那么遍历效果可能会碰到如下问题：新增的键可能没有遍历到，遍历出了重
   
     复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键，这些是
   
     我们在开发时需要考虑的。
   - 大列表避免使用 `LINDEX`，改用 ZSet 按索引存储
2. **利用批量操作**：
   
   - 使用 `MGET`、`MSET`、`PIPELINE` 减少网络往返，提升批量操作效率
   - 事务（`MULTI`/`EXEC`）可保证多个命令的原子性执行
3. **数据结构选择**：
   - 小集合用 `intset`（内存更优），大集合用哈希表
   - 有序数据优先使用 ZSet（跳表），避免列表的 O (N) 范围查询
4. **过期策略优化**：
   - 合理设置过期时间，减少内存占用
   - 对时效性要求高的数据使用 `EXPIRE`，而非主动调用 `DEL`

redis是单线程还是多线程？
io是多线程，处理命令是单线程。

### 为什么单线程能这么快？
第一，纯内存访问，Redis将所有数据放在内存中，内存的响应时长大

约为100纳秒，这是Redis达到每秒万级别访问的重要基础。

第二，非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上

Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不

在网络I/O上浪费过多的时间

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果

某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务

来说是致命的，所以Redis是面向快速执行场景的数据库。





慢查询

![image-20250724175752381](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724175752381.png)

需要注意，慢查询只统计步骤3）的时间，所以没有慢查询并不代表客

户端没有超时问题。

3.1.1 慢查询的两个配置参数

对于慢查询功能，需要明确两件事：

·预设阀值怎么设置？

·慢查询记录存放在哪？

Redis提供了slowlog-log-slower-than和slowlog-max-len配置来解决这两个

问题。从字面意思就可以看出，slowlog-log-slower-than就是那个预设阀值，

它的单位是微秒（1秒=1000毫秒=1000000微秒），默认值是10000，假如执

行了一条“很慢”的命令（例如keys*），如果它的执行时间超过了10000微

秒，那么它将被记录在慢查询日志中。

查看 大于多少微妙会将数据存入日志中：CONFIG GET slowlog-log-slower-than

- 若返回值为 **大于 0 的整数**（单位：微秒），表示已开启（仅记录执行时间超过该阈值的命令）。
- 若返回值为 **0**，表示记录所有命令（不推荐，会占用大量资源）。
- 若返回值为 **负数**（如 `-1`），表示关闭慢查询日志。

查看日志记录的数据条数：CONFIG GET slowlog-max-len

​	如slowlog-max-len设置为5，当有第6条慢查询，插入的话，那么队头的第一条数据就出列，第6条慢查询就会入列。

slowlog len：获取慢查询日志列表当前的长度
slowlog reset ：清空慢查询日志

slowlog get [n]: 获取日志，n为条数

可以使用info replication命令查看复制相关

状态