# Redis基础知识

>  Redis:remote dictionary service的简称，远程字典服
>
> 所有数据库都是请求回应模式，通过tcp和redis建立连接交互
>
> 通过字典的方式索引搜索，kv数据库，所有的key都是string
>
> 内存数据库：所有数据都在内存中。不会存在一部分数据在内存，一部分数据在磁盘中。

### redis常用数据结构

- string ： 字符串，和c++中的string一样，都是二进制安全的

> 1. **二进制安全**
>    - 可以存储任意二进制数据（如图片、序列化对象等）
>    - 长度不依赖于特定字符（如 C 语言中的 `\0` 终止符）
>    - 最大长度为 512MB

- List : 列表

- hash

- set：集合，里面元素不会相同

- zset：有序集合, 里面的member不会相同，根据score排序

  > 第一次用什么命令决定了这个key是什么数据结构，比如set key ’asdfad‘ ，那么key的结构为string

![image-20250621145840861](/Users/shilinling/Library/Application Support/typora-user-images/image-20250621145840861.png)

### redis中命令

## 对key的命令

- ##### `DEL key [key ...]`

  - **功能**：删除一个或多个键
  - **原理**：从数据库字典中删除键值对，释放内存
  - **时间复杂度**：O (N)，N 为删除的键数量
  - **内存回收**：Redis 使用惰性删除和定期删除策略，DEL 是立即删除，会释放内存

- ##### `EXPIRE key seconds`

  - **功能**：设置键的过期时间
  - **原理**：将键的过期时间存入过期字典，到期后通过惰性或定期删除处理
  - **时间复杂度**：O(1)
  - **过期策略**：惰性删除（访问时检查）+ 定期删除（随机抽查），避免全量扫描

- ##### `KEYS pattern`

  - **功能**：查找匹配模式的键
  - **原理**：遍历数据库字典的所有键，用模式匹配算法过滤
  - **时间复杂度**：O (N)，N 为数据库键数量
  - **性能风险**：在生产环境禁止使用 KEYS，会阻塞主线程，建议用 `SCAN` 替代

- ##### `PERSIST key`

  - **功能**：移除键的过期时间
  - **原理**：从过期字典中删除该键的记录
  - **时间复杂度**：O(1)
  - **应用场景**：适用于临时数据转永久存储的场景

- 

dump key 序列化key，并返回系列化的值

exists key 检查key是否存在

expire key seconds 设置过期时间，以s计

expireat key timestamp 

key的迁移

- `key的迁移`

  - move key db//将key放到另外一个db上。move命令在Redis内部数据库之间迁移数据

  - dump+restore可以实现在不同的Redis实例之间进行数据迁移的功能，

    - 1）在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。

      2）在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参

      数代表过期时间，如果ttl=0代表没有过期时间。

      ![image-20250724163646511](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724163646511.png)

      3）migrate命令也是用于在Redis实例间进行数据迁移的，实际上migrate命

      令就是将dump、restore、del三个命令进行组合，migrate命令具有原子性

      ```bash
      MIGRATE host port key|"" destination-db timeout [COPY] [REPLACE] [KEYS key1 key2 ...]
      ```

      #### 参数说明：

      | 参数              | 含义                                                         |                                                              |
      | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | `host`            | 目标 Redis 实例的 IP 地址或主机名。                          |                                                              |
      | `port`            | 目标 Redis 实例的端口号。                                    |                                                              |
      | `key              | ""`                                                          | 要迁移的单个 key；若使用 `KEYS` 选项批量迁移，此处需设为空字符串 `""`。 |
      | `destination-db`  | 目标实例中接收 key 的数据库编号（Redis 默认有 16 个库，编号 0-15）。 |                                                              |
      | `timeout`         | 迁移操作的超时时间（毫秒），若超过此时长未完成则失败。       |                                                              |
      | `[COPY]`          | 可选参数，默认迁移后会删除源实例的 key；加上 `COPY` 则保留源 key。 |                                                              |
      | `[REPLACE]`       | 可选参数，若目标实例中已存在同名 key，默认迁移失败；加上 `REPLACE` 则覆盖目标 key。 |                                                              |
      | `[KEYS key1 ...]` | 可选参数，用于批量迁移多个 key，此时前面的 `key` 参数必须设为 `""`。 |                                                              |

      ### 三、使用示例

      #### 1. 迁移单个 key

      将源实例的 `user:100` 迁移到目标实例（`192.168.1.100:6379`）的数据库 0，超时时间 5000 毫秒（5 秒），迁移后删除源 key：

      ```bash
      MIGRATE 192.168.1.100 6379 user:100 0 5000
      ```

      #### 2. 迁移单个 key 并保留源实例的 key

      使用 `COPY` 参数，迁移后源实例仍保留 `user:100`：

      ```bash
      MIGRATE 192.168.1.100 6379 user:100 0 5000 COPY
      ```

      #### 3. 迁移时覆盖目标实例的同名 key

      若目标实例已有 `user:100`，用 `REPLACE` 强制覆盖：

      ```bash
      MIGRATE 192.168.1.100 6379 user:100 0 5000 REPLACE
      ```

      #### 4. 批量迁移多个 key

      迁移 `user:100`、`order:200`、`product:300` 三个 key 到目标实例，此时第一个 `key` 参数需设为 `""`，并通过 `KEYS` 指定批量 key：

      ```bash
      MIGRATE 192.168.1.100 6379 "" 0 5000 KEYS user:100 order:200 product:300
      ```

![image-20250724164953143](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724164953143.png)

## string

- `GET key`

  - **功能**：获取字符串类型键的值
  - **原理**：通过哈希表（字典）直接查询键值对，Redis 字典采用链地址法解决哈希冲突
  - **时间复杂度**：O(1)
  - **实现细节**：字典的底层是哈希表，查找操作通过哈希函数计算槽位，平均情况下直接定位到目标节点

- ##### `SET key value [EX seconds] [PX milliseconds] [NX|XX]`

  - **功能**：设置字符串值，支持过期时间和条件赋值
  - 原理
    - 直接更新哈希表中的键值对
    - 过期时间通过过期字典（另一层哈希表）维护
    - `NX/XX` 通过原子操作实现条件判断
  - **时间复杂度**：O(1)
  - **实现细节**：SET 命令在 Redis 中是原子操作，通过 `setKey` 函数完成字典更新，过期时间存储在 `redisObject` 结构中

- ##### `INCR key`

  - **功能**：对数值型字符串自增 1
  - 原理
    - 检查值是否为整数，非整数报错
    - 直接在内存中进行数值运算，不涉及字符串解析
    - 结果重新写入哈希表
  - **时间复杂度**：O(1)
  - **实现细节**：Redis 用 `sds`（简单动态字符串）存储字符串，数值型会特殊标记，INCR 直接操作数值而非字符串转换

- ##### `MGET key1 [key2 ...]`

  - **功能**：批量获取多个键的值
  - **原理**：循环执行 GET 操作，通过哈希表逐个查询
  - **时间复杂度**：O (N)，N 为键的数量
  - **优化点**：相比多次单 GET，减少网络往返次数，提升批量操作效率

![image-20250724143806796](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724143806796.png)

## list

- ##### `LPUSH key value [value ...]`

  - **功能**：在列表左侧插入元素
  - 原理
    - 列表底层由双向链表（quicklist）实现
    - 新元素创建节点后插入链表头部
  - **时间复杂度**：O(1)
  - **数据结构**：quicklist 是压缩列表（ziplist）的链表，当元素较少时使用压缩列表优化内存

- ##### `RPOP key`

  - **功能**：从列表右侧弹出元素
  - **原理**：通过双向链表尾指针直接访问最后一个节点，删除并返回值
  - **时间复杂度**：O(1)
  - **实现细节**：双向链表支持 O (1) 时间的头尾操作，中间操作需遍历

- ##### `LINDEX key index`

  - **功能**：获取列表指定索引的元素
  - **原理**：从链表头部或尾部开始遍历，直到找到目标索引
  - **时间复杂度**：O (N)，N 为列表长度
  - **性能提示**：大列表应避免频繁使用 LINDEX，可改用有序集合（ZSet）按索引存储

- ##### `LRANGE key start stop`

  - **功能**：获取列表指定范围的元素
  - **原理**：根据 start 和 stop 确定遍历方向（从头或从尾），分段读取元素
  - **时间复杂度**：O (S+N)，S 为起始偏移量，N 为返回元素数
  - **优化点**：Redis 会对范围进行边界检查，若 start 超过列表长度则返回空

- Redis的lpush+brpop命令组合即可实现阻塞队列，生产

  者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令

  阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用

  性。

![image-20250724151031150](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724151031150.png)

## hash

- ##### `HSET key field value`

  - **功能**：在哈希表中设置字段值
  - 原理
    - 键对应的值是一个哈希表（字典），字段作为内层字典的键
    - 采用链地址法解决哈希冲突
  - **时间复杂度**：O(1)
  - **实现细节**：当哈希表节点数超过阈值时，会触发渐进式 rehash，避免阻塞主线程

- ##### `HGET key field`

  - **功能**：获取哈希表中字段的值
  - **原理**：通过外层字典找到哈希表，再在内层字典中查询字段
  - **时间复杂度**：O(1)
  - **内存优化**：当字段数较少且值为小整数时，会使用压缩列表（ziplist）存储，减少内存占用

- ##### `HGETALL key`

  - **功能**：获取哈希表所有字段和值
  - **原理**：遍历内层字典的所有节点，收集键值对
  - **时间复杂度**：O (N)，N 为字段数量
  - **性能风险**：若哈希表包含大量字段，会阻塞主线程，建议分批获取或使用 `HSCAN` 渐进式遍历

- ##### `HINCRBY key field increment`

  - **功能**：对哈希表中的数值字段自增指定值
  - **原理**：直接操作内层字典的数值型字段，无需字符串解析
  - **时间复杂度**：O(1)
  - **应用场景**：适用于计数器场景，如用户积分系统

![image-20250724145705403](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724145705403.png)

## set

- ##### `SADD key member [member ...]`

  - **功能**：向集合中添加元素（去重）
  - 原理
    - 集合底层使用哈希表或有序整数数组（intset）
    - 当元素为整数且数量较少时使用 intset，否则用哈希表
  - **时间复杂度**：平均 O (1)，最坏 O (N)（哈希冲突时）
  - **内存优化**：intset 存储整数时比哈希表更节省内存，且查找效率更高

- ##### `SISMEMBER key member`

  - **功能**：判断元素是否在集合中
  - **原理**：根据底层数据结构选择哈希表查询或二分查找（intset）
  - **时间复杂度**：O (1)（哈希表）或 O (logN)（intset）
  - **实现细节**：intset 是有序的，通过二分查找提升查询效率

- ##### `SMEMBERS key`

  - **功能**：获取集合所有元素
  - **原理**：遍历底层数据结构（哈希表或 intset）的所有元素
  - **时间复杂度**：O (N)，N 为集合元素数量
  - **性能风险**：大集合使用 SMEMBERS 会阻塞主线程，建议用 `SSCAN` 渐进式遍历

- ##### `SINTER key1 [key2 ...]`

  - **功能**：计算多个集合的交集
  - 原理
    - 以最小集合为基准，遍历元素检查是否存在于其他集合
    - 底层通过哈希表的 `dictFind` 实现快速查找
  - **时间复杂度**：O (N*M)，N 为最小集合元素数，M 为集合数量
  - **优化策略**：Redis 会自动选择最小的集合作为基准，减少遍历次数

![image-20250724154125086](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724154125086.png)

## zset

- ##### `ZADD key score member [score member ...]`

  - **功能**：向有序集合添加元素（按分数排序）
  - 原理
    - 底层使用跳表（skiplist）和哈希表双重结构
    - 跳表用于按分数排序，哈希表用于 O (1) 时间查询分数
  - **时间复杂度**：O (logN)，跳表插入操作的平均时间复杂度
  - **数据结构**：跳表的层级随机生成，保证查找、插入、删除均为 O (logN) 复杂度

- ##### `ZSCORE key member`

  - **功能**：获取元素的分数
  - **原理**：通过哈希表直接查询元素对应的分数
  - **时间复杂度**：O(1)
  - **实现细节**：哈希表的键是元素值，值是对应的分数，与跳表共享数据

- ##### `ZRANGE key start stop [WITHSCORES]`

  - **功能**：按排名获取有序集合元素（升序）
  - **原理**：从跳表头部开始遍历，按层级快速定位目标范围
  - **时间复杂度**：O (logN + M)，N 为集合大小，M 为返回元素数
  - **优化点**：跳表的多层索引结构允许快速跳过无关元素，提升范围查询效率

- ##### `ZREMRANGEBYRANK key start stop`

  - **功能**：按排名删除元素
  - **原理**：在跳表中找到起始和结束位置，删除对应节点
  - **时间复杂度**：O (logN + M)，M 为删除元素数
  - **底层操作**：跳表删除节点后会重新平衡层级，保证后续操作效率

![image-20250724154521840](/Users/shilinling/Library/Application Support/typora-user-images/image-20250724154521840.png)



对数据库操作

Redis默认配置中是有16个数据库：假设databases=16，select0操作将切换到第一个数据库，select15选择最

后一个数据库，但是0号数据库和15号数据库之间的数据没有任何关联

Redis3.0中已经逐渐弱化这个功能，例如Redis的分布式实现Redis

Cluster只允许使用0号数据库，只不过为了向下兼容老版本的数据库功能，

该功能没有完全废弃掉，下面分析一下为什么要废弃掉这个“优秀”的功能

呢？总结起来有三点：

·Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用

一个CPU，彼此之间还是会受到影响的。

多数据库的使用方式，会让调试和运维不同业务的数据库变的困难，

假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定

位问题非常的困难。

·部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候

来回切换数字形式的数据库，很容易弄乱。





2.flushdb/flushall

flushdb/flushall命令用于清除数据库，两者的区别的是flushdb只清除当

前数据库，flushall会清除所有数据库。
