#### 一、Bitmap 底层结构

Redis 的 Bitmap（位图）是一种**紧凑的二进制数据结构**，底层通过**字符串（SDS，简单动态字符串）** 实现。它将数据存储为连续的二进制位（bit），每个位对应一个偏移量（offset），取值为 `0` 或 `1`。

- **存储特点**：
  一个字符串可以存储任意长度的二进制数据，Bitmap 利用这一点，将每个位映射到具体的逻辑含义（如标记用户是否活跃、签到状态等）。例如，偏移量 `0` 对应第 1 位，偏移量 `1` 对应第 2 位，以此类推。
- **内存效率**：
  存储 `N` 个状态仅需 `N/8` 字节（1 字节 = 8 位），比用集合（Set）存储节省大量内存（如存储 1000 万个用户的签到状态，仅需约 1.2MB）。

#### 二、Bitmap 集合操作的时间复杂度

Bitmap 支持的集合操作主要通过以下命令实现，其时间复杂度与**位图的最大偏移量**相关（假设两个位图的最大偏移量分别为 `M` 和 `N`，取较大值为 `max(M, N)`）：

| 操作   | 命令示例                 | 含义                                 | 时间复杂度   |
| ------ | ------------------------ | ------------------------------------ | ------------ |
| 交集   | `BITOP AND dest bm1 bm2` | 计算两个位图的交集                   | O(max(M, N)) |
| 并集   | `BITOP OR dest bm1 bm2`  | 计算两个位图的并集                   | O(max(M, N)) |
| 差集   | `BITOP XOR dest bm1 bm2` | 计算两个位图的异或（可间接实现差集） | O(max(M, N)) |
| 非运算 | `BITOP NOT dest bm1`     | 对位图进行取反                       | O(M)         |

#### 三、关键说明

1. **差集的实现**：
   Redis 没有直接的 “差集” 命令（如 `BITOP DIFF`），但可通过**异或 + 与运算**间接实现：

   - 公式：`A - B = A & (~B)`（A 中存在且 B 中不存在的位）。

   - 步骤：

     ```bash
     BITOP NOT temp_b B    # 对 B 取反，得到 temp_b  
     BITOP AND dest A temp_b  # A 与 temp_b 做交集，即 A - B  
     ```

   整体时间复杂度仍为 `O(max(M, N))`（两次 `BITOP` 操作的总和）。

2. **时间复杂度的本质**：
   `BITOP` 命令需要遍历两个位图中所有的位（从偏移量 `0` 到最大偏移量），对每个位执行对应的逻辑运算（与、或、异或等），因此时间复杂度与最大偏移量线性相关。

   - 若位图的最大偏移量很大（如 1 亿），单次 `BITOP` 操作可能耗时较长（毫秒级），需避免在高频场景中使用。

3. **与 Set 集合操作的对比**：
   Set 的交集（`SINTER`）、并集（`SUNION`）、差集（`SDIFF`）时间复杂度为 `O(N)`（`N` 为集合中元素数量），而 Bitmap 的优势在于**内存效率更高**，但操作耗时受最大偏移量影响更大（即使实际有效位很少，也需遍历到最大偏移量）。

### 总结

- **底层结构**：Bitmap 基于字符串（SDS）实现，通过二进制位存储状态，内存效率极高。
- **集合操作复杂度**：交集、并集、差集（间接实现）的时间复杂度均为 `O(max(M, N))`，取决于位图的最大偏移量。
- **使用建议**：适合存储海量二值状态（如签到、在线状态），但需控制最大偏移量，避免集合操作耗时过长。