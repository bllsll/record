Redis 的 HyperLogLog 是一种用于**基数统计**的概率性数据结构，能以极小的内存空间（约 12KB）高效估算大规模数据集的基数（即集合中不重复元素的数量）。适合场景：统计独立访客（UV）、独立 IP 数、搜索关键词去重计数等。

### 一、核心命令及用法

HyperLogLog 提供 3 个核心命令，语法简单：

#### 1. 添加元素：`PFADD`

向 HyperLogLog 结构中添加一个或多个元素（重复元素不影响最终计数）。

```bash
# 语法：PFADD key element1 [element2 ...]
PFADD uv:20250724 user1 user2 user3  # 向"20250724的UV统计"中添加3个用户
```

- 返回值：`1` 表示 HyperLogLog 内部结构被修改（新增了之前未统计的元素）；`0` 表示无新元素添加。

#### 2. 估算基数：`PFCOUNT`

计算 HyperLogLog 中不重复元素的估算数量。

```bash
# 语法：PFCOUNT key [key ...]
PFCOUNT uv:20250724  # 估算20250724的独立用户数，返回结果类似：(integer) 3
```

- 支持同时统计多个 key 的合并基数（如跨天 UV 总和）：

  ```bash
  PFCOUNT uv:20250724 uv:20250725  # 估算两天的总独立用户数
  ```

#### 3. 合并多个 HyperLogLog：`PFMERGE`

将多个 HyperLogLog 合并为一个新的 HyperLogLog，新结构的基数约等于所有源结构的并集基数。

```bash
# 语法：PFMERGE destkey sourcekey1 [sourcekey2 ...]
PFMERGE uv:202507  uv:20250724 uv:20250725  # 合并7月24日和25日的UV，存入uv:202507
PFCOUNT uv:202507  # 查看7月前两天的总UV
```

### 二、特点与限制

1. **内存效率极高**：
   无论统计的元素数量是 100 还是 10 亿，单个 HyperLogLog 仅占用约 **12KB 内存**（相比 Set 存储节省几个数量级）。
2. **概率性估算**：
   结果不是精确值，存在约 0.81% 的误差（Redis 官方数据），但对 UV 统计等场景完全可接受。
3. **不存储原始数据**：
   仅记录基数估算所需的概率信息，无法像 Set 那样取出具体元素，也无法删除单个元素（如需重置，只能用 `DEL` 命令删除整个 HyperLogLog）。

### 三、使用场景示例

#### 统计网站每日独立访客（UV）

```bash
# 用户访问时，添加用户ID到当天的HyperLogLog
PFADD uv:20250724 alice bob charlie

# 当天结束后，查询UV
PFCOUNT uv:20250724  # 结果：3

# 每周汇总
PFMERGE uv:2025w28 uv:20250722 uv:20250723 uv:20250724  # 合并周一至周三
PFCOUNT uv:2025w28  # 得到本周前三天的总UV
```

### 四、注意事项

- **误差可接受性**：适合允许小幅误差的场景，若需精确计数（如订单去重），需用 Set 或 Hash。
- **元素类型**：输入元素会被视为字符串（如数字 `123` 和字符串 `"123"` 会被视为同一个元素）。
- **内存占用稳定**：即使添加再多元素，内存也不会显著增长（始终约 12KB）。

### 总结

HyperLogLog 是 “空间换精度” 的典型应用，用 12KB 内存即可处理亿级数据的基数统计，适合 UV、独立 IP 等无需精确值的场景。核心命令 `PFADD`、`PFCOUNT`、`PFMERGE` 简单易用，是 Redis 中性价比极高的功能之一。





HyperLogLog 的核心是：

1. 利用哈希函数将元素映射为随机二进制串；
2. 通过 “第一个 1 出现的位置” 量化元素的随机性；
3. 分组记录最大值并取平均，用概率分布反推基数。

这种设计让它能用 12KB 内存处理亿级数据，虽有小幅误差，但在 UV 统计、独立 IP 计数等场景中性价比极高，是 “空间换精度” 的经典实现。