Redis 的 **跳表（skiplist）** 是一种有序数据结构，通过在每个节点中维护多个指向其他节点的指针（“索引”），实现快速的查找、插入和删除操作。它是 Redis 有序集合（`sorted set`）的底层实现之一（当有序集合包含大量元素，或元素成员是较长字符串时使用，与哈希表、压缩列表配合）。跳表的设计平衡了效率与实现复杂度，其平均时间复杂度为 **O(logN)**，最坏情况为 **O(N)**，但在实际场景中性能接近平衡树（如红黑树），且实现更简单。

### 一、跳表的基本结构

Redis 跳表由 **`zskiplist`（跳表本体）** 和 **`zskiplistNode`（跳表节点）** 两部分组成，结构如下：

#### 1. `zskiplistNode`：跳表节点

每个节点存储一个有序集合的元素（包含分值 `score` 和成员 `obj`），并通过多个层级的指针连接其他节点。结构定义（简化）：

```c
typedef struct zskiplistNode {
    robj *obj;               // 成员对象（如字符串对象）
    double score;            // 分值，用于排序（有序集合的排序依据）
    struct zskiplistNode *backward;  // 后退指针（指向当前节点的前一个节点，用于反向遍历）
    struct zskiplistLevel {  // 层级结构（每个层级包含一个前进指针和跨度）
        struct zskiplistNode *forward;  // 前进指针（指向同一层级的下一个节点）
        unsigned int span;              // 跨度（当前节点到 forward 指向节点的距离，用于计算排名）
    } level[];               // 柔性数组，存储多个层级（层级数动态生成）
} zskiplistNode;
```

关键字段解析：

- **`score`**：节点的分值，跳表中所有节点按 `score` 从小到大排序（相同 `score` 的节点按 `obj` 的字典序排序）。

- **`backward`**：后退指针，仅指向当前节点的前一个节点（单指针），用于从尾节点向头节点反向遍历（如 `ZREVRANGE` 命令）。

- `level`：层级数组，每个元素是一个zskiplistLevel

   结构，包含：

  - `forward`：前进指针，指向同一层级中 “下一个比当前节点分值大” 的节点（若为最后一个节点则指向 `NULL`）。
  - `span`：前进指针跨越的节点数量（即当前节点到 `forward` 节点之间有多少个节点），用于快速计算节点的排名（如 `ZRANK` 命令）。

- **层级数量**：每个节点的层级数（`level` 数组的长度）是**随机生成**的（通常称为 “层高”），最小值为 1，最大值由 Redis 常量 `ZSKIPLIST_MAXLEVEL` 限制（默认 32）。

#### 2. `zskiplist`：跳表本体

跳表本体用于管理所有节点，记录跳表的全局信息。结构定义（简化）：

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;  // 头节点、尾节点（头节点是哨兵，不存储实际数据）
    unsigned long length;                 // 跳表中的节点总数（不包含头节点）
    int level;                            // 跳表当前的最高层级（头节点的层级不计入）
} zskiplist;
```

关键字段解析：

- **`header`**：头节点（哨兵节点），不存储实际的 `score` 和 `obj`，仅用于简化查找、插入等操作的逻辑（作为所有层级的起始点）。其 `level` 数组长度为 `ZSKIPLIST_MAXLEVEL`（默认 32）。
- **`tail`**：尾节点，指向跳表中最后一个节点（分值最大的节点）。
- **`length`**：跳表中实际节点的数量（方便 `ZCARD` 命令直接返回集合大小）。
- **`level`**：跳表当前的最高层级（即所有节点中层级最大的值），头节点的层级不影响此值。

### 二、核心特性：随机层级的生成

跳表的高效性依赖于节点层级的 “随机分布”。每个节点的层级数通过随机算法生成，规则如下：

- 初始层级为 1。
- 有 50% 的概率将层级加 1（即 `P(level = k) = (1/2)^(k-1) * 1/2`，如层级为 1 的概率是 1/2，层级为 2 的概率是 1/4，层级为 3 的概率是 1/8，以此类推）。
- 层级上限为 `ZSKIPLIST_MAXLEVEL`（默认 32），即使随机生成的层级超过 32，也会被截断为 32。

这种分布使得跳表的层级结构类似 “多层索引”：

- 底层（层级 1）包含所有节点（类似原始链表）。
- 高层级（如层级 2、3...）包含部分节点，作为底层的 “索引”，层级越高，节点越稀疏。

例如，一个包含 6 个节点的跳表可能的层级分布：

```plaintext
层级 3：[header] -> 节点A ----------------------------------> 节点F
层级 2：[header] -> 节点A ---------> 节点C ------------------> 节点F
层级 1：[header] -> 节点A -> 节点B -> 节点C -> 节点D -> 节点E -> 节点F
```

- 层级 3 作为最高级索引，跳过了中间多数节点，可快速定位到目标范围。
- 层级 1 是完整链表，保证数据的有序性。

### 三、核心操作原理

#### 1. 查找操作（如 `ZSCORE`、`ZRANK`）

查找的目标是根据 `score` 和 `obj` 定位节点，步骤如下：

- **步骤 1：从最高层级开始遍历**
  从 `header` 的最高层级（`zskiplist.level`）开始，初始化当前节点为 `header`，当前层级为最高级。
- **步骤 2：沿前进指针前进，遇大则降层**
  对于当前层级 `i`：
  - 若当前节点的 `forward[i]` 指向的节点分值小于目标分值，或分值相等但成员字典序更小，则移动到 `forward[i]` 指向的节点（继续在当前层级前进）。
  - 若 `forward[i]` 指向的节点分值大于目标分值，或已到达尾节点，则层级减 1（`i--`），继续在低一层级查找。
- **步骤 3：到达层级 1 后定位结果**
  当层级降至 1 时，若当前节点的 `forward[1]` 指向的节点分值和成员与目标匹配，则找到节点；否则，节点不存在。

**示例**：在上述 6 节点跳表中查找 “节点 D”（分值假设为 4）：

- 从层级 3 开始：`header.forward[3]` 指向节点 A（分值 1 < 4）→ 移动到节点 A。
- 节点 A.forward [3] 指向节点 F（分值 6 > 4）→ 层级降为 2。
- 节点 A.forward [2] 指向节点 C（分值 3 < 4）→ 移动到节点 C。
- 节点 C.forward [2] 指向节点 F（分值 6 > 4）→ 层级降为 1。
- 节点 C.forward [1] 指向节点 D（分值 4 = 4）→ 找到节点 D。

时间复杂度：**平均 O (logN)**，最坏 O (N)（若所有节点层级均为 1，退化为链表）。

#### 2. 插入操作（如 `ZADD`）

插入需要先确定节点的层级、找到各层级的前驱节点，再调整指针，步骤如下：

- **步骤 1：生成节点的随机层级**
  按随机层级规则生成新节点的层级 `new_level`（若 `new_level` 大于跳表当前的 `level`，则更新跳表 `level` 为 `new_level`）。
- **步骤 2：记录各层级的前驱节点**
  遍历跳表（类似查找操作），对于每个层级 `i`（从最高级到 1），记录当前节点（即新节点在层级 `i` 的前驱节点），存储在 `update[i]` 数组中（`update` 数组长度为 `ZSKIPLIST_MAXLEVEL`）。同时记录各层级移动的总跨度（用于计算新节点的排名）。
- **步骤 3：创建新节点并调整指针**
  初始化新节点（设置 `score`、`obj`、`level` 数组长度为 `new_level`），然后为每个层级 `i`（1 到 `new_level`）：
  - 新节点的 `forward[i]` 指向 `update[i].forward[i]`（即前驱节点原来的下一个节点）。
  - 前驱节点的 `forward[i]` 指向新节点（将新节点插入到前驱节点之后）。
  - 新节点的 `span[i]` 设为 `update[i].span[i] - (当前节点到前驱节点的跨度)`（根据实际距离计算）。
  - 前驱节点的 `span[i]` 设为 `(当前节点到新节点的跨度) + 新节点的 span[i]`。
- **步骤 4：设置后退指针**
  新节点的 `backward` 指向层级 1 中前驱节点（`update[1]`），若 `update[1]` 是 `header`，则新节点的 `backward` 为 `NULL`（表示是第一个节点）。
- **步骤 5：更新跳表长度**
  跳表的 `length` 加 1。

**示例**：插入 “节点 G”（分值 7）到上述 6 节点跳表，生成 `new_level=2`：

- 各层级前驱节点：`update[2] = 节点F`，`update[1] = 节点F`。
- 节点 G 的 `forward[2] = 节点F.forward[2]`（`NULL`），`forward[1] = 节点F.forward[1]`（`NULL`）。
- 节点 F 的 `forward[2]` 和 `forward[1]` 均指向节点 G。
- 节点 G 的 `backward` 指向节点 F。

#### 3. 删除操作（如 `ZREM`）

删除需要先找到节点及各层级的前驱节点，再移除指针，步骤如下：

- **步骤 1：查找节点及各层级的前驱**
  类似插入操作，遍历跳表，找到目标节点，并记录各层级的前驱节点（存储在 `update` 数组中）。若节点不存在，则直接返回。
- **步骤 2：调整前驱节点的指针**
  对于每个层级 `i`（1 到节点的层级）：
  - 若 `update[i].forward[i]` 指向目标节点，则将 `update[i].forward[i]` 指向目标节点的 `forward[i]`（跳过目标节点）。
  - 更新前驱节点的 `span[i]` 为 `update[i].span[i] + 目标节点的 span[i]`（合并跨度）。
- **步骤 3：更新跳表的最高层级**
  若目标节点的层级等于跳表的 `level`，且删除后 `header.forward[level]` 为 `NULL`（即最高层级已无节点），则将跳表 `level` 减 1（重复此过程直到 `level` 为 1 或最高层级有节点）。
- **步骤 4：更新后退指针**
  若目标节点有后驱节点（`forward[1]` 不为 `NULL`），则后驱节点的 `backward` 指向目标节点的 `backward`（即前驱节点）。
- **步骤 5：释放节点并更新长度**
  释放目标节点的内存，跳表的 `length` 减 1。

### 四、与平衡树的对比：为什么 Redis 选择跳表？

有序集合需要支持**范围查询**（如 `ZRANGE`、`ZREVRANGE`）、**按分值 / 排名操作**（如 `ZADD`、`ZRANK`）等，跳表与红黑树等平衡树均可满足，但跳表的优势在于：

| 特性         | 跳表（skiplist）                 | 红黑树（Red-Black Tree）       |
| ------------ | -------------------------------- | ------------------------------ |
| 实现复杂度   | 简单（无需旋转等复杂操作）       | 复杂（插入删除需维护树平衡）   |
| 范围查询效率 | 高效（沿层级指针连续遍历）       | 需中序遍历，效率相近但实现复杂 |
| 并发性能     | 更易实现无锁操作（指针调整简单） | 锁粒度难以控制，易冲突         |
| 内存占用     | 较高（多指针）                   | 较低（仅左右子树指针）         |

Redis 选择跳表，主要因为其**实现简单**且**范围查询高效**，更符合 Redis 对 “高性能 + 易维护” 的设计目标。

### 五、总结

Redis 跳表是一种通过 “多层索引” 实现的有序数据结构，核心特点：

- **结构**：由 `zskiplist` 管理节点，`zskiplistNode` 包含多个层级的前进指针和跨度。
- **随机层级**：节点层级按 50% 概率递增生成，保证查找效率接近 O (logN)。
- **操作**：查找、插入、删除均通过层级遍历实现，范围查询高效。
- **应用**：作为有序集合的底层实现，支撑高并发的排序和范围操作。

跳表的设计平衡了效率与复杂度，是 Redis 高性能的重要保障之一。



- redis的跳表，就是在一个存储数据的双向链表上建立多级索引链表的结构。
- 每个跳表节点保存了obj指针，score，一个前驱指针和一个level数组，level数组是level节点，每个level节点保存了该level层下一个level节点的指针和跨度。
- 新节点使用一个类似于连续抛硬币的随机算法确定层数，最低也有一层，即level0层。
- 最多应该是64层吧，一个宏定义的。
- level0层和跳表节点存储的obj和score还有前驱指针共同组成了一个双向链表。
- 创建过程就是寻找节点的过程，从最高层level层开始找每层level链表的终点(最大的小于目标值的那个节点)，最终找到目标节点，途中每层的终点记录下来，更新指针和跨度，一个过程顺便记录每层跨度和，最后累加起来就是目标节点的rank。
- 跳表绝大多数情况下性能和平衡树相当，但实现起来比平衡树简单，而且更适合范围查找，更加适合实现zset的结构。
- zset实际上是跳表加字典，字典用来实现set的功能，跳表用来实现rank的功能

