

Redis 的 `intset`（整数集合）是集合键（`set` 类型）的底层实现之一，专门用于存储**不重复的整数元素**。当一个集合满足 “所有元素都是整数” 且 “元素数量不超过配置 `set-max-intset-entries`（默认 512）” 时，Redis 会选择 `intset` 作为底层结构，而非哈希表（`dict`），以节省内存空间。

### 一、intset 的设计目标

`intset` 的核心设计目标是**在保证整数元素唯一性的前提下，用最紧凑的内存存储数据**，同时支持高效的增删查操作。与哈希表相比，`intset` 的优势在于：

- 内存占用极低（无哈希表的指针、元数据等冗余开销）。
- 对于小数量级的整数集合，操作效率接近哈希表（平均 O (logN) 时间复杂度）。

### 二、intset 的核心结构

`intset` 是一个**有序、无重复**的整数数组，其结构定义（简化）如下：

```c
typedef struct intset {
    uint32_t encoding;  // 编码方式（决定存储的整数类型）
    uint32_t length;    // 元素数量（集合大小）
    int8_t contents[];  // 柔性数组，存储整数元素（实际类型由 encoding 决定）
} intset;
```

#### 1. 关键字段解析

- **`encoding`**：标记集合中整数的存储类型，有三种取值：

  - `INTSET_ENC_INT16`：每个元素是 `int16_t` 类型（2 字节，范围：-32768 ~ 32767）。
  - `INTSET_ENC_INT32`：每个元素是 `int32_t` 类型（4 字节，范围：-2147483648 ~ 2147483647）。
  - `INTSET_ENC_INT64`：每个元素是 `int64_t` 类型（8 字节，范围：-9223372036854775808 ~ 9223372036854775807）。

  所有元素共用同一编码，确保内存布局紧凑（无类型混合存储）。

- **`length`**：记录集合中元素的数量（非数组容量，而是实际存储的元素个数）。

- **`contents`**：柔性数组（变长数组），实际存储整数元素。数组中的元素**按升序排列且无重复**，这是实现高效查找和去重的关键。

#### 2. 内存布局示例

假设一个 `intset` 存储元素 `{1, 3, 5}`，编码为 `INTSET_ENC_INT16`（2 字节 / 元素），其内存布局如下：

```plaintext
偏移量（字节）：0  1  2  3  4  5  6  7  8  9  10 11
内容：         [encoding][length][1][3][5]
               （2字节） （2字节）（2）（2）（2）
```

- `encoding` 字段值为 `INTSET_ENC_INT16`（宏定义为 2）。
- `length` 字段值为 3（3 个元素）。
- `contents` 数组依次存储 1、3、5（每个占 2 字节，按升序排列）。

### 三、核心操作原理

`intset` 的所有操作（添加、删除、查找）都依赖于其**有序性**，通过**二分查找**定位元素位置，保证效率。

#### 1. 查找元素（`intsetFind`）

查找操作的目标是判断一个整数是否存在于集合中，步骤如下：

- **步骤 1：确定元素的潜在编码**
  根据目标整数的大小，判断其需要的编码（如 65535 需要 `INTSET_ENC_INT32`，因超过 `int16_t` 最大值）。

- **步骤 2：二分查找定位位置**
  由于 `contents` 数组是有序的，使用二分查找快速定位元素：

  - 若找到与目标值相等的元素，返回其在数组中的索引。
  - 若未找到，返回插入该元素的位置（用于后续添加操作）。

  时间复杂度为 **O(logN)**（N 为 `length`）。

#### 2. 添加元素（`intsetAdd`）

添加元素时，需保证集合有序性和唯一性，可能触发编码升级，步骤如下：

- **步骤 1：检查元素是否已存在**
  通过 `intsetFind` 查找元素，若已存在则直接返回（不重复添加）。

- **步骤 2：判断是否需要编码升级**
  若目标元素的取值范围超过当前 `encoding` 支持的范围（如当前是 `INTSET_ENC_INT16`，添加 65535 需 `INTSET_ENC_INT32`），则触发**编码升级**：

  1. 计算新编码（能容纳所有元素的最小编码）。
  2. 重新分配内存（新容量 = `length + 1`，每个元素按新编码占用字节）。
  3. 将原有元素**从后往前**迁移到新内存（避免覆盖数据），并按新编码存储。
     1. 这里为什么会覆盖数据，见下面讲解
  4. 更新 `encoding` 字段为新编码。
  
- **步骤 3：插入新元素**
  找到插入位置后，将该位置及之后的元素**向后移动一个位置**（腾出空间），然后插入新元素，最后 `length` 加 1。

  **示例**：向 `INTSET_ENC_INT16` 编码的 `{1, 3, 5}` 中添加 65535（需 `INTSET_ENC_INT32`）：

  1. 升级编码为 `INTSET_ENC_INT32`（4 字节 / 元素）。
  2. 原有元素 1、3、5 按 4 字节重新存储。
  3. 插入 65535 到合适位置，结果为 `{1, 3, 5, 65535}`，`length=4`。

#### 3. 删除元素（`intsetRemove`）

删除元素时，需先定位元素位置，再移动后续元素填补空缺，步骤如下：

- **步骤 1：查找元素位置**
  通过 `intsetFind` 确认元素存在，获取其索引。

- **步骤 2：移动后续元素**
  将该索引之后的所有元素**向前移动一个位置**（覆盖被删除元素）。

- **步骤 3：更新长度**
  `length` 减 1（无需缩小内存，避免频繁分配释放）。

  时间复杂度为 **O(N)**（最坏情况需移动 N-1 个元素）。

#### 4. 编码升级的特性

编码升级是 `intset` 的重要机制，具有以下特点：

- **单向性**：只能从低编码（`INT16`）升级到高编码（`INT32`/`INT64`），**不能降级**（即使删除了大整数，编码也保持不变）。
  例：添加 65535 后编码升级为 `INT32`，删除 65535 后，编码仍为 `INT32`（避免频繁转换开销）。
- **原子性**：升级过程中，所有元素按新编码重新存储，保证内存布局一致性。

### 四、与哈希表的对比

当集合元素满足 `intset` 条件时，Redis 优先选择 `intset`，原因如下：

| 特性            | intset                   | 哈希表（dict）           |
| --------------- | ------------------------ | ------------------------ |
| 内存占用        | 极低（紧凑数组，无冗余） | 较高（指针、元数据开销） |
| 查找效率        | O (logN)（二分查找）     | O (1)（平均）            |
| 插入 / 删除效率 | O (N)（移动元素）        | O (1)（平均）            |
| 适用场景        | 小数量整数集合           | 大量元素或非整数集合     |

当元素数量超过 `set-max-intset-entries`（默认 512），或插入非整数元素时，Redis 会自动将 `intset` 转换为哈希表。

### 五、总结

`intset` 是 Redis 针对 “小数量整数集合” 设计的高效存储结构，核心特点：

- **有序无重复**：元素按升序排列，通过二分查找快速定位。
- **编码自适应**：根据元素大小自动升级编码，平衡存储效率和兼容性。
- **内存紧凑**：无冗余指针和元数据，内存利用率远高于哈希表。

其设计体现了 Redis “因地制宜” 的优化思想 —— 针对不同数据特征选择最适合的存储结构，在性能和内存之间取得最佳平衡。













在 Redis intset 的编码升级过程中，新分配的内存块可能与原内存块存在地址重叠，核心原因与 **内存分配策略** 和 **效率优化** 有关。具体来说，这是操作系统或内存分配器（如 Redis 自定义的内存分配器）为了减少内存碎片、提升分配效率而采取的 “原地扩容” 策略导致的。

### 内存分配的底层逻辑：优先原地扩容

Redis 中的内存分配依赖底层函数（如 C 标准库的 `realloc`，或 Redis 自定义的 `zmalloc` 系列函数）。当需要为一个已存在的内存块（如 intset）分配更大的空间时，内存分配器的行为通常是：

1. **先检查原地是否有足够空间**：
   查看当前内存块（原 intset）的**后面是否有连续的空闲内存**，且大小满足扩容需求。如果有，直接在原地扩展内存块，无需移动数据。
   - 此时，新内存块的起始地址与原内存块相同，长度更大（包含原内存块的全部区域 + 新增的空闲区域）。
   - 这种情况下，**新内存块与原内存块必然重叠**（原内存块是新内存块的一部分）。
2. **若原地空间不足，才分配新地址**：
   如果当前内存块后面没有足够的连续空闲空间，分配器会在内存的其他区域分配一块新的、足够大的内存，并将原内存块的数据复制到新内存块中，最后释放原内存块。
   - 此时，新内存块与原内存块地址完全独立，**不存在重叠**。